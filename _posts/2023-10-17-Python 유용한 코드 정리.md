---
layout: post
title: "Python 유용한 코드 정리"
summary: "Python 유용한 코드 정리"
author: taehun
date: '2023-10-17 19:00:00 +0900'
category: Python
toc: true
toc_sticky: true
toc_label: "My Table of Contents"
toc_icon: "cog"
thumbnail: null
keywords: Python
permalink: /21
mathjax: true
use_math: true
---

Last update: 2023.10.31<br>

> Python 유용한 코드 정리<br>

#### Index
---

- [1. Operator](#1-operator)
- [2. Einstein summation](#2-einstein-summation)
- [3. Decorator](#3-decorator)<br><br>

#### **1. Operator**
  
<br>

1) Unpacking Dictionary Items: The ** operator는 dictionary의 contents들을 함수 등에 unpack할 때 사용함
<br>

```python
def greet(first_name="", last_name=""):
    print(f"Hello, {first_name} {last_name}!")

person_info = {"first_name": "John", "last_name": "Doe"}
greet(**person_info)  # Outputs: Hello, John Doe!
```

이 예제에서는, 함수 입력 변수들을 key로 가지는 person_info를 operator를 사용한 **person_info를 입력으로 넣어서, dictionary의 contents를 unpack함

2) 함수를 정의할 때 **kwargs는 기존에 설정하지 않은 변수(함수의 입력으로 활용될 추가적인 변수)를 정의할 때 사용함

```python
def example_func(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

example_func(a=1, b=2, c=3)
# Outputs:
# a: 1
# b: 2
# c: 3
```

이 예제에서는 함수 정의 시, **kwargs를 입력으로 받는 것으로 정의함으로써, 임의의 변수 a, b, c에 대한 값을 변수로 활용용 가능

#### **2. Einstein summation**

1) Transpose

```python
A = torch.randint(1, 10, (2,2))
B = torch.einsum('ij->ji', A)
```

2) Sum of total element

```python
A = torch.randint(1, 10, (2,2))
sum = torch.einsum('ij->', A)
```

3) Column/row sum
   
```python
A = torch.randint(1, 10, (2,2))
# Column sum
col_sum = torch.einsum('ij->j', A)
row_sum = torch.einsum('ij->i', A)
```

4) Matrix multiplication
   
```python
A = torch.randint(1, 10, (2,3))
B = torch.randint(1, 10, (3,2))
b = torch.randint((1, 10, (3))

Ab = torch.einsum('ij,j->i', A,b)
AB = torch.einsum('ij,jk->ik', A,B)
```

5) Dot/outer/Hadamard product

```python
a = torch.randint(1, 10, (2))
b = torch.randint(1, 10, (2))
A = torch.randint(1, 10, (2,3))
B = torch.randint(1, 10, (3,2))

a_dot_b = torch.einsum('i,i->', a,b)
a_outer_b = torch.einsum('i,j->ij', a,b) # dyadic product
A_had_B = torch.einsum('ij,ij->ij', A,B)
```

6) Batch matrix multiplication

```python
A = torch.randint(1, 10, (100, 2,3))
B = torch.randint(1, 10, (100, 3,2))

A_bmm_B = torch.einsum('ijk,ikl->ijl', A,B)
```

7) Bilinear transformation

```python
A = torch.randint(1, 10, (2,3))
B = torch.randint(1, 10, (3,4,5))
C = torch.randint(1, 10, (5,2))

ABC = torch.einsum('ij,jkl,lm->ikm', A,B,C)
```

#### **3. Decorator**

<br>

- Decorator는 함수를 수정하지 않은 상태에서 추가 기능을 구현할 때 사용
- 함수 정의 시, 바로 위에 decorator를 호출함으로써, decorator에 사전에 정의된 기능을 function 앞뒤로 실행

<br>

예시(아래 결과를 얻기 위해 decorator 사용 유무에 따라 2가지 방식으로 진행)

```python
hello 함수 시작
hello
hello 함수 끝

world 함수 시작
world
world 함수 끝
```

- **방식 1(decorator 사용 X)**

```python
def deco(func):                      # 호출할 함수를 매개변수로 받음
  def wrapper():                     # 호출할 함수를 감싸는 함수
    print(func.__name__, "함수 시작") # __name__으로 함수 이름 출력
    func()                           # 매개변수로 받은 함수를 호출
    print(func.__name__, "함수 끝")
  return wrapper                     # wrapper 함수 반환

def hello():
  print('hello')

def world():
  print('world')

deco_hello = deco(hello)             # 데코레이터에 호출할 함수를 넣음
deco_hello()                         # 반한된 함수를 호출
deco_world = deco(world)             # 데코레이터에 호출할 함수를 넣음
deco_world()                         # 반한된 함수를 호출
```

- **방식 2(decorator 사용)**

```python
def deco(func):                      # 호출할 함수를 매개변수로 받음
  def wrapper():                     # 호출할 함수를 감싸는 함수
    print(func.__name__, "함수 시작") # __name__으로 함수 이름 출력
    func()                           # 매개변수로 받은 함수를 호출
    print(func.__name__, "함수 끝")
  return wrapper                     # wrapper 함수 반환

@deco
def hello():
   print('hello')

@deco
def world():
  print('world')

hello()
world()
```

<br>

